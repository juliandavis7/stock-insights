# Code Generated by Sidekick is for learning and experimentation purposes only.
import yfinance as yf
import requests
from typing import Dict, List, Any, Optional
from datetime import datetime
import json
from .constants import FMP_API_KEY, FMP_ANALYST_ESTIMATES_URL

def fetch_fmp_analyst_estimates(ticker, api_key=FMP_API_KEY):
    url = f"{FMP_ANALYST_ESTIMATES_URL}?symbol={ticker}&period=annual&page=0&limit=10&apikey={api_key}"
    try:
        resp = requests.get(url)
        resp.raise_for_status()
        return resp.json()
    except Exception as e:
        print(f"FMP API Error: {e}")
        return []

def get_ttm_pe(stock_info):
    val = stock_info.get('trailingPE', None)
    return round(val, 2) if val is not None else None

def get_forward_pe(stock_info):
    val = stock_info.get('forwardPE', None)
    return round(val, 2) if val is not None else None

def get_ttm_ps(stock_info):
    val = stock_info.get('priceToSalesTrailing12Months', None)
    return round(val, 2) if val is not None else None

def get_gross_margin(stock_info):
    val = stock_info.get('grossMargins', None)
    return round(val, 2) if val is not None else None

def get_net_margin(stock_info):
    val = stock_info.get('profitMargins', None)
    return round(val, 2) if val is not None else None

def get_earnings_growth(stock_info):
    val = stock_info.get('earningsGrowth', None)
    return round(val * 100, 2) if val is not None else None

def get_revenue_growth(stock_info):
    val = stock_info.get('revenueGrowth', None)
    return round(val * 100, 2) if val is not None else None

def get_current_year_eps_growth(earnings_forecast):
    try:
        return round(earnings_forecast.loc['0y', 'growth'] * 100, 2)
    except Exception:
        return None

def get_next_year_eps_growth(earnings_forecast):
    try:
        return round(earnings_forecast.loc['+1y', 'growth'] * 100, 2)
    except Exception:
        return None

def get_current_year_revenue_growth(revenue_forecast):
    try:
        return round(revenue_forecast.loc['0y', 'growth'] * 100, 2)
    except Exception:
        return None

def get_next_year_revenue_growth(revenue_forecast):
    try:
        return round(revenue_forecast.loc['+1y', 'growth'] * 100, 2)
    except Exception:
        return None

def get_forward_ps_ratio(stock_info, revenue_forecast):
    try:
        market_cap = stock_info.get('marketCap', None)
        next_year_revenue = revenue_forecast.loc['+1y', 'avg']
        if market_cap is None or next_year_revenue is None or next_year_revenue == 0:
            return None
        return round(market_cap / next_year_revenue, 2)
    except Exception:
        return None

def get_two_year_forward_pe(ticker, current_price, api_key=FMP_API_KEY):
    estimates = fetch_fmp_analyst_estimates(ticker, api_key)
    years = sorted([int(item["date"][:4]) for item in estimates], reverse=True)
    if not years or len(years) < 3:
        return None
    target_year = str(years[2])
    for estimate in estimates:
        if estimate["date"].startswith(target_year):
            eps = estimate.get("epsAvg")
            if eps is not None and eps != 0:
                return round(current_price / eps, 2)
    return None

def get_metrics(ticker):
    stock = yf.Ticker(ticker)
    stock_info = stock.info

    try:
        earnings_forecast = stock.earnings_estimate
    except Exception:
        earnings_forecast = None
    try:
        revenue_forecast = stock.revenue_estimate
    except Exception:
        revenue_forecast = None

    current_price = stock_info.get("regularMarketPrice", None)
    two_year_forward_pe = None
    if current_price is not None:
        two_year_forward_pe = get_two_year_forward_pe(ticker, current_price)

    metrics = {
        "TTM_PE": get_ttm_pe(stock_info),
        "Forward_PE": get_forward_pe(stock_info),
        "2_Year_Forward_PE": two_year_forward_pe,
        "TTM_EPS_Growth": get_earnings_growth(stock_info),
        "Current_Year_EPS_Growth": get_current_year_eps_growth(earnings_forecast) if earnings_forecast is not None else None,
        "Next_Year_EPS_Growth": get_next_year_eps_growth(earnings_forecast) if earnings_forecast is not None else None,
        "TTM_Revenue_Growth": get_revenue_growth(stock_info),
        "Current_Year_Revenue_Growth": get_current_year_revenue_growth(revenue_forecast) if revenue_forecast is not None else None,
        "Next_Year_Revenue_Growth": get_next_year_revenue_growth(revenue_forecast) if revenue_forecast is not None else None,
        "Gross_Margin": get_gross_margin(stock_info),
        "Net_Margin": get_net_margin(stock_info),
        "TTM_PS_Ratio": get_ttm_ps(stock_info),
        "Forward_PS_Ratio": get_forward_ps_ratio(stock_info, revenue_forecast),
    }
    return metrics

def extract_metric_by_year(fmp_data, metric):
    """
    fmp_data: list of dicts from FMP analyst-estimates API
    metric: string, e.g. "revenueAvg", "netIncomeAvg", "epsAvg"
    returns: dict mapping year (int) to metric value (float)
    """
    metric_by_year = {}
    for item in fmp_data:
        if "date" in item and metric in item:
            year = int(item["date"][:4])
            metric_by_year[year] = item[metric]
    return metric_by_year


def fetch_stock_info(ticker: str) -> Optional[Dict[str, float]]:
    """
    Fetch current stock price and shares outstanding using yfinance.
    
    Args:
        ticker: Stock ticker symbol (e.g., 'AAPL')
    
    Returns:
        Dictionary with current stock price and shares outstanding, or None if error
    """
    try:
        stock = yf.Ticker(ticker)
        info = stock.info
        
        # Get current stock price (try multiple fields as they can vary)
        current_price = (
            info.get('currentPrice') or 
            info.get('regularMarketPrice') or 
            info.get('previousClose')
        )
        
        # Get shares outstanding (try multiple fields)
        shares_outstanding = (
            info.get('sharesOutstanding') or 
            info.get('impliedSharesOutstanding') or 
            info.get('floatShares')
        )
        
        if current_price is None or shares_outstanding is None:
            return None
            
        return {
            'current_stock_price': float(current_price),
            'shares_outstanding': float(shares_outstanding)
        }
        
    except Exception as e:
        print(f"Error fetching stock info for {ticker}: {e}")
        return None


def fetch_current_year_data(ticker: str, api_key: str) -> Optional[Dict[str, float]]:
    """
    Fetch current year financial data from FMP API.
    
    Args:
        ticker: Stock ticker symbol (e.g., 'AAPL')
        api_key: FMP API key
    
    Returns:
        Dictionary with current year revenue and net income, or None if error
    """
    try:
        # FMP API endpoint for analyst estimates
        url = "https://financialmodelingprep.com/stable/analyst-estimates"
        params = {
            "symbol": ticker,
            "period": "annual",
            "page": 0,
            "limit": 10,
            "apikey": api_key
        }
        
        response = requests.get(url, params=params)
        response.raise_for_status()
        
        data = response.json()
        
        if not data:
            return None
        
        # Get current year data
        current_year = datetime.now().year
        current_year_data = None
        
        for record in data:
            if record.get('date'):
                # Extract year from date (format: YYYY-MM-DD)
                record_year = int(record['date'][:4])
                if record_year == current_year:
                    current_year_data = record
                    break
        
        if not current_year_data:
            return None
        
        return {
            'revenue': current_year_data.get('revenueAvg', 0),
            'net_income': current_year_data.get('netIncomeAvg', 0)
        }
        
    except requests.exceptions.RequestException as e:
        print(f"API request failed: {e}")
        return None
    except (KeyError, ValueError, json.JSONDecodeError) as e:
        print(f"Error parsing API response: {e}")
        return None


def validate_projection_inputs(projection_inputs: Dict[int, Dict[str, float]]) -> List[str]:
    """
    Validate the projection inputs and return any error messages.
    
    Args:
        projection_inputs: The projection inputs dictionary
    
    Returns:
        List of error messages (empty if no errors)
    """
    errors = []
    current_year = datetime.now().year
    valid_years = set(range(current_year + 1, current_year + 5))
    
    for year, inputs in projection_inputs.items():
        if year not in valid_years:
            errors.append(f"Invalid year {year}. Must be between {current_year + 1} and {current_year + 4}")
        
        required_fields = ['revenue_growth', 'net_income_growth', 'pe_low', 'pe_high']
        for field in required_fields:
            if field not in inputs:
                errors.append(f"Missing required field '{field}' for year {year}")
            elif not isinstance(inputs[field], (int, float)):
                errors.append(f"Field '{field}' for year {year} must be a number")
        
        # Validate ranges
        if 'revenue_growth' in inputs:
            if inputs['revenue_growth'] < -0.5 or inputs['revenue_growth'] > 1.0:
                errors.append(f"Revenue growth for year {year} must be between -50% and 100%")
        
        if 'net_income_growth' in inputs:
            if inputs['net_income_growth'] < -1.0 or inputs['net_income_growth'] > 2.0:
                errors.append(f"Net income growth for year {year} must be between -100% and 200%")
        
        if 'net_income_margin' in inputs:
            if inputs['net_income_margin'] < 0 or inputs['net_income_margin'] > 0.5:
                errors.append(f"Net income margin for year {year} must be between 0% and 50%")
        
        # Validate PE ratios are positive
        if 'pe_low' in inputs and inputs['pe_low'] <= 0:
            errors.append(f"PE low for year {year} must be positive")
        if 'pe_high' in inputs and inputs['pe_high'] <= 0:
            errors.append(f"PE high for year {year} must be positive")
        if 'pe_low' in inputs and 'pe_high' in inputs and inputs['pe_low'] > inputs['pe_high']:
            errors.append(f"PE low must be less than or equal to PE high for year {year}")
    
    return errors


def calculate_financial_projections(
    ticker: str,
    api_key: str,
    projection_inputs: Dict[int, Dict[str, float]],
    shares_outstanding: Optional[float] = None,
    current_stock_price: Optional[float] = None,
    current_year_data: Optional[Dict[str, float]] = None
) -> Dict[str, Any]:
    """
    Calculate financial projections for a stock based on growth assumptions.
    
    Args:
        ticker: Stock ticker symbol (e.g., 'AAPL')
        api_key: FMP API key
        projection_inputs: Dictionary with year as key and projection data as value
        shares_outstanding: Optional - Number of shares outstanding
        current_stock_price: Optional - Current stock price
        current_year_data: Optional - Current year financial data
    
    Returns:
        Dictionary containing projections for each year with calculated metrics
    """
    
    # Fetch current year data if not provided
    if current_year_data is None:
        current_year_data = fetch_current_year_data(ticker, api_key)
        if current_year_data is None:
            return {
                'success': False,
                'error': f'Failed to fetch current year data for {ticker}',
                'ticker': ticker
            }
    
    # Fetch stock info if not provided
    if shares_outstanding is None or current_stock_price is None:
        stock_info = fetch_stock_info(ticker)
        if stock_info is None:
            return {
                'success': False,
                'error': f'Failed to fetch stock info for {ticker}',
                'ticker': ticker
            }
        
        if shares_outstanding is None:
            shares_outstanding = stock_info['shares_outstanding']
        if current_stock_price is None:
            current_stock_price = stock_info['current_stock_price']
    
    current_year = datetime.now().year
    projections = {}
    
    # Validate projection years (should be current year + 1 to current year + 4)
    valid_years = list(range(current_year + 1, current_year + 5))
    
    # Initialize starting values
    prev_revenue = current_year_data['revenue']
    prev_net_income = current_year_data['net_income']
    
    for year in valid_years:
        if year not in projection_inputs:
            continue
            
        inputs = projection_inputs[year]
        
        # Calculate projected revenue
        revenue_growth = inputs['revenue_growth']
        projected_revenue = prev_revenue * (1 + revenue_growth)
        
        # Calculate projected net income (using growth rate)
        net_income_growth = inputs['net_income_growth']
        projected_net_income = prev_net_income * (1 + net_income_growth)
        
        # Calculate EPS
        eps = projected_net_income / shares_outstanding
        
        # Calculate stock price estimates using PE ratios
        pe_low = inputs['pe_low']
        pe_high = inputs['pe_high']
        
        stock_price_low = eps * pe_low
        stock_price_high = eps * pe_high
        
        # Calculate CAGR (Compound Annual Growth Rate) from current year
        years_from_current = year - current_year
        cagr_low = ((stock_price_low / current_stock_price) ** (1/years_from_current)) - 1
        cagr_high = ((stock_price_high / current_stock_price) ** (1/years_from_current)) - 1
        
        # Store projections for this year
        projections[year] = {
            'revenue': round(projected_revenue, 2),
            'net_income': round(projected_net_income, 2),
            'eps': round(eps, 2),
            'stock_price_low': round(stock_price_low, 2),
            'stock_price_high': round(stock_price_high, 2),
            'cagr_low': round(cagr_low * 100, 2),  # Convert to percentage
            'cagr_high': round(cagr_high * 100, 2)  # Convert to percentage
        }
        
        # Update previous values for next iteration
        prev_revenue = projected_revenue
        prev_net_income = projected_net_income
    
    return {
        'success': True,
        'ticker': ticker,
        'current_year': current_year,
        'base_data': {
            'revenue': current_year_data['revenue'],
            'net_income': current_year_data['net_income'],
            'stock_price': current_stock_price,
            'shares_outstanding': shares_outstanding
        },
        'projections': projections,
        'summary': {
            'projection_years': list(projections.keys()),
            'total_years_projected': len(projections)
        }
    }