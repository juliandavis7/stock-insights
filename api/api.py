# Code Generated by Sidekick is for learning and experimentation purposes only.
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from .models import MetricsResponse, ProjectionRequest, ProjectionResponse, ProjectionBaseDataResponse, ErrorResponse
from .util import get_metrics, fetch_fmp_analyst_estimates, extract_metric_by_year, calculate_financial_projections, validate_projection_inputs
from .services.projection_service import ProjectionService
from .constants import FMP_API_KEY

app = FastAPI()

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://127.0.0.1:5173"],  # React frontend
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)


@app.get("/health")
def health_check():
    return {"status": "ok"}

@app.get("/metrics", response_model=MetricsResponse)
def metrics(ticker: str = Query(..., description="Stock ticker symbol")):
    data = get_metrics(ticker)
    # The refactored service already returns the correct field names
    return data

@app.get("/revenue")
def get_revenue(ticker: str = Query(..., description="Stock ticker symbol")):
    fmp_data = fetch_fmp_analyst_estimates(ticker)
    if not fmp_data:
        raise HTTPException(status_code=404, detail="No data found for ticker")
    revenue_dict = extract_metric_by_year(fmp_data, "revenueAvg")
    return revenue_dict

# Code Generated by Sidekick is for learning and experimentation purposes only.
@app.get("/net-income")
def get_net_income(ticker: str = Query(..., description="Stock ticker symbol")):
    fmp_data = fetch_fmp_analyst_estimates(ticker)
    if not fmp_data:
        raise HTTPException(status_code=404, detail="No data found for ticker")
    net_income_dict = extract_metric_by_year(fmp_data, "netIncomeAvg")
    return net_income_dict

@app.get("/eps")
def get_eps(ticker: str = Query(..., description="Stock ticker symbol")):
    fmp_data = fetch_fmp_analyst_estimates(ticker)
    if not fmp_data:
        raise HTTPException(status_code=404, detail="No data found for ticker")
    eps_dict = extract_metric_by_year(fmp_data, "epsAvg")
    return eps_dict

@app.post("/projections", response_model=ProjectionResponse)
async def create_financial_projections(
    request: ProjectionRequest,
    ticker: str = Query(..., description="Stock ticker symbol (e.g., AAPL)", regex="^[A-Z]{1,5}$")
):
    """
    Calculate financial projections for a stock based on user assumptions.
    
    Args:
        ticker: Stock ticker symbol as query parameter
        request: Projection inputs in request body
    
    Returns:
        Financial projections including revenue, net income, EPS, stock price ranges, and CAGR
    """
    
    # Convert Pydantic models to dictionary format expected by utils
    projection_inputs = {}
    for year, projection in request.projections.items():
        projection_inputs[year] = {
            'revenue_growth': projection.revenue_growth,
            'net_income_growth': projection.net_income_growth,
            'net_income_margin': projection.net_income_margin,
            'pe_low': projection.pe_low,
            'pe_high': projection.pe_high
        }
    
    # Validate inputs using utility function
    validation_errors = validate_projection_inputs(projection_inputs)
    if validation_errors:
        raise HTTPException(
            status_code=400, 
            detail={
                "error": "Validation failed",
                "details": validation_errors
            }
        )
    
    # Calculate projections
    try:
        result = calculate_financial_projections(
            ticker=ticker.upper(),
            api_key=FMP_API_KEY,
            projection_inputs=projection_inputs
        )
        
        if not result.get('success', True):
            raise HTTPException(
                status_code=400,
                detail={
                    "error": result.get('error', 'Unknown error occurred'),
                    "ticker": ticker
                }
            )
        
        return ProjectionResponse(**result)
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": f"Internal server error: {str(e)}",
                "ticker": ticker
            }
        )


@app.get("/projections", response_model=ProjectionBaseDataResponse)
def get_projection_base_data(ticker: str = Query(..., description="Stock ticker symbol")):
    """
    Get base data for financial projections including current stock metrics.
    
    Args:
        ticker: Stock ticker symbol (e.g., CELH, AAPL)
        
    Returns:
        Base data including price, market cap, shares outstanding, and financial metrics
    """
    try:
        projection_service = ProjectionService()
        data = projection_service.get_stock_current_data(ticker.upper(), FMP_API_KEY)
        
        if not data:
            raise HTTPException(
                status_code=404,
                detail={
                    "error": f"Unable to fetch data for ticker {ticker}",
                    "ticker": ticker.upper()
                }
            )
        
        # Calculate net income margin if we have both net income and revenue
        net_income_margin = None
        if data.get('net_income') and data.get('revenue') and data['revenue'] > 0:
            net_income_margin = (data['net_income'] / data['revenue']) * 100
        
        return ProjectionBaseDataResponse(
            ticker=data['ticker'],
            price=data['price'],  
            market_cap=data['market_cap'],
            shares_outstanding=data['shares_outstanding'],
            revenue=data.get('revenue'),
            net_income=data.get('net_income'),
            eps=data.get('current_year_eps'),
            net_income_margin=net_income_margin,
            data_year=data['data_year']
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": f"Internal server error: {str(e)}",
                "ticker": ticker.upper()
            }
        )
